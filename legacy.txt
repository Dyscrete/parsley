#include <stdio.h>
#include <stdlib.h>
#include <argp.h>
#include <json/json.h>
#include "kstring.h"
#include "obstack.h"
#include "dexter.h"
#include "y.tab.h"
#include "printbuf.h"
#include <string.h>
#include <errno.h>
#include <ctype.h>
#include <stdbool.h>
#include <libxslt/xslt.h>
#include <libxslt/xsltInternals.h>
#include <libxslt/transform.h>
#include <libxml/parser.h>
#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/xmlwriter.h>
#include <libexslt/exslt.h>

int yywrap(void){
  return 1;
}

xmlDocPtr dex_parse_file(dexPtr dex, char* file, boolean html) {
	if(html) {
		htmlParserCtxtPtr htmlCtxt = htmlNewParserCtxt();
  	htmlDocPtr html = htmlCtxtReadFile(htmlCtxt, file, "UTF-8", 3);
		if(html == NULL) {
			asprintf(&dex->error, "Couldn't parse file: %s\n", file);
			return NULL;
		}
		return dex_parse_doc(dex, html);
	} else {
		xmlParserCtxtPtr ctxt = xmlNewParserCtxt();
		xmlDocPtr xml = xmlCtxtReadFile(ctxt, file, "UTF-8", 3);
		if(xml == NULL) {
			asprintf(&dex->error, "Couldn't parse file: %s\n", file);
			return NULL;
		}
		return dex_parse_doc(dex, xml);
	}
}

xmlDocPtr dex_parse_string(dexPtr dex, char* string, size_t size, boolean html) {
	if(html) {
		htmlParserCtxtPtr htmlCtxt = htmlNewParserCtxt();
  	htmlDocPtr html = htmlCtxtReadMemory(htmlCtxt, string, size, "http://foo", "UTF-8", 3);
		if(html == NULL) {
			asprintf(&dex->error, "Couldn't parse string\n");
			return NULL;
		}
		return dex_parse_doc(dex, html);
	} else {
		xmlParserCtxtPtr ctxt = xmlNewParserCtxt();
 		xmlDocPtr xml = xmlCtxtReadMemory(ctxt, string, size, "http://foo", "UTF-8", 3);
		if(xml == NULL) {
			asprintf(&dex->error, "Couldn't parse string\n");
			return NULL;
		}
		return dex_parse_doc(dex, xml);
	}
}

xmlDocPtr dex_parse_doc(dexPtr dex, xmlDocPtr doc) {
	return xsltApplyStylesheet(dex->stylesheet, doc, NULL);
}

static contextPtr clone_context(contextPtr context) {
	contextPtr other;
	other = __dex_alloc(sizeof(dex_context));
	other->name = astrdup(context->name);
	other->expr = astrdup(context->expr);
	other->keys = clone_list(context->keys);
	return other;
}

static contextPtr tagged_context(contextPtr context, char* tag) {
	contextPtr other = clone_context(context);
	other->name = astrcat3(context->name, ".", tag);
	return other;
}

static contextPtr init_context() {
	contextPtr other;
	other = __dex_alloc(sizeof(dex_context));
	other->name = "root";
	other->expr = "/";
	other->keys = NULL;
	return other;
}

static char* inner_key_of(struct json_object * json) {
	switch(json_object_get_type(json)) {
		case json_type_string: 
			return json_object_get_string(json);
		case json_type_array:
			return NULL;
		case json_type_object:
			return inner_key_each(json);
	}
}

static char* inner_key_each(struct json_object * json) {
	json_object_object_foreach(json, key, val) {
		char* inner = inner_key_of(val);
		if(inner != NULL) return inner;
	}
	return NULL;
}

static strsPtr clone_list(strsPtr list) {
	if(list == NULL) return NULL;
	strsPtr other = __dex_alloc(sizeof(strs));
	other->direction = list->direction;
	other->name = astrdup(list->name);
	other->expr = astrdup(list->expr);
	other->next = clone_list(list->next);
	return other;
}

dexPtr dex_compile(char* dex_str, char* incl) {
	dexPtr dex = (dexPtr) calloc(sizeof(compiled_dex), 1);
	
	if(last_dex_error != NULL) {
		free(last_dex_error);
		last_dex_error = NULL;
	}
	
  if(!dex_exslt_registered) {
    exsltRegisterAll();
    dex_exslt_registered = true;
  }

	obstack_init(&dex_obstack);
	
	struct json_object *json = json_tokener_parse(dex_str);
	if(is_error(json)) {
		dex->error = strdup("Your dex is not valid json.");
		return dex;
	}

	struct printbuf* buf = printbuf_new();
	
	sprintbuf(buf, "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"");
	sprintbuf(buf, " xmlns:dexter=\"http://kylemaxwell.com/dexter\"");
	sprintbuf(buf, " xmlns:str=\"http://exslt.org/strings\"");
	sprintbuf(buf, " xmlns:set=\"http://exslt.org/sets\"");
	sprintbuf(buf, " xmlns:math=\"http://exslt.org/math\"");
	sprintbuf(buf, " xmlns:func=\"http://exslt.org/functions\"");
	sprintbuf(buf, " xmlns:user=\"http://kylemaxwell.com/dexter/user-functions\"");
	sprintbuf(buf, " xmlns:dyn=\"http://exslt.org/dynamic\"");
	sprintbuf(buf, " xmlns:date=\"http://exslt.org/dates-and-times\"");
	sprintbuf(buf, " xmlns:exsl=\"http://exslt.org/common\"");
	sprintbuf(buf, " xmlns:saxon=\"http://icl.com/saxon\"");
	sprintbuf(buf, " extension-element-prefixes=\"str math set func dyn exsl saxon user date\"");
	sprintbuf(buf, ">\n");
	sprintbuf(buf, "<xsl:output method=\"xml\" indent=\"yes\"/>\n");
	sprintbuf(buf, "<xsl:strip-space elements=\"*\"/>\n");
	sprintbuf(buf, "%s\n", incl);
	sprintbuf(buf, "<xsl:template match=\"/\">\n");
	sprintbuf(buf, "<dexter:root>\n");
	
	contextPtr context = init_context();
	xslt_keys = "<!-- keys -->";
	next_context = 0;
	
	__dex_simple_single_object(json, buf, context);
	
	json_object_put(json); // frees json
	dex->error = last_dex_error;
	
	sprintbuf(buf, "</dexter:root>\n");
	sprintbuf(buf, "</xsl:template>\n");
	sprintbuf(buf, xslt_keys);
	sprintbuf(buf, "</xsl:stylesheet>\n");
	
	if(dex->error == NULL) {
		xmlParserCtxtPtr ctxt = xmlNewParserCtxt();
		xmlDocPtr doc = xmlCtxtReadMemory(ctxt, buf->buf, buf->size, "http://kylemaxwell.com/some-dex", "UTF-8", 3);
		dex->stylesheet = xsltParseStylesheetDoc(doc);
	}
	
	printbuf_free(buf);
	obstack_free(&dex_obstack, NULL);
	
	return dex;
}

void dex_free(dexPtr ptr) {
	if(ptr->error != NULL) free(ptr->error);
	if(ptr->stylesheet != NULL) xsltFreeStylesheet(ptr->stylesheet);
	free(ptr);
}

void * __dex_alloc(int size) {
	return obstack_alloc(&dex_obstack, size);
}

void yyerror(const char * s) {
	struct printbuf *buf = printbuf_new();
	if(last_dex_error !=NULL) sprintbuf(buf, "%s\n", last_dex_error);
  sprintbuf(buf, "%s in key: %s", s, dex_parsing_context->name);
	last_dex_error = strdup(buf->buf);
	printbuf_free(buf);
}

char* __tag(char* key) {
	char *tag = astrdup(key);
	char *ptr = tag;
	while(*ptr++ != '\0'){
		if(*ptr == '(') {
			*ptr = 0;
			return tag;
		}
	}
	return tag;
}

char* __filter(char* key) {
	char *expr = astrdup(key);
	char *ptr = expr;

	int offset = 0;
	bool has_expr = false;

	while(*ptr++ != '\0'){
		offset++;
		if(*ptr == '(') {
			has_expr = true;
			break;
		}
	}
	if(!has_expr) return NULL;

	expr += offset + 1; // clip "("
	int l = strlen(expr);
	if(l <= 1) return NULL;
	*(expr + l - 1) = 0; // clip ")"
	return myparse(expr);
}

void __dex_simple_single_object(struct json_object * json, struct printbuf* buf, contextPtr orig_context) {
	char* tag;
	char* filter;
	struct json_object * inner;
	int contains_object;
	contextPtr context;
	json_object_object_foreach(json, key, val) {
		// printf("a\n");
		tag = __tag(key);
		filter = __filter(key);
		sprintbuf(buf, "<%s>\n", tag);	
				// printf("b\n");
		context = tagged_context(orig_context, tag);
		switch(json_object_get_type(val)){
		case json_type_object:
			if(filter) {
				// printf("c\n");
				printf("WTF!\n");
			} else {
				// printf("d\n");
				__dex_simple_single_object(val, buf, context);
			}
			break;
		case json_type_string:
			if(filter != NULL) {
				printf("WTF!!!!!!!\n");
			} else {
				// printf("e\n");
				__dex_simple_single_string(val, buf, context);
			}
			break;
		case json_type_array:
			// printf("q: %s\n", filter);
			inner = json_object_array_get_idx(val, 0);
			contains_object = json_object_is_type(inner, json_type_object);
			if(filter){
				if(contains_object) {
					// printf("f\n");
					__dex_filter_array_object(inner, buf, context, filter);
				} else {
					printf("WTF!!!!!!!\n");
				}
			} else {
				if(contains_object) {
					// printf("g\n");
					__dex_magic_array_object(inner, buf, context);
				} else {
					// printf("h\n");
					__dex_simple_array_string(inner, buf, context);
				}
			}
			break;
		case json_type_boolean:
		case json_type_double:
		case json_type_int:
		default:
			fprintf(stderr, "Invalid type in json\n");
			exit(1);
		}
		sprintbuf(buf, "</%s>\n", tag);	
  }
}

static void __dex_simple_single_string(struct json_object * json, struct printbuf * buf, contextPtr context){
	char* expr = myparse(astrdup(json_object_get_string(json)));
	sprintbuf(buf, "<xsl:variable name=\"%s\" select=\"%s\" />\n", context->name, expr);
	sprintbuf(buf, "<xsl:variable name=\"%s\" select=\"$%s\" />\n", __tag(context->name), context->name);
	sprintbuf(buf, "<xsl:value-of select=\"$%s\" />\n", context->name);
}

static void __dex_filter_array_object(struct json_object * json, struct printbuf * buf, contextPtr context, char* filter){
	sprintbuf(buf, "<dexter:groups><xsl:for-each select=\"%s\"><dexter:group>\n", filter);	
	__dex_simple_single_object(json, buf, context);
	sprintbuf(buf, "</dexter:group></xsl:for-each></dexter:groups>\n");	
}

static void __dex_magic_array_object(struct json_object * json, struct printbuf * buf, contextPtr context){
	char* expr = myparse(astrdup(inner_key_of(json)));
	sprintbuf(buf, "<dexter:groups><xsl:for-each select=\"%s\"><dexter:group>\n", expr);	
	sprintbuf(buf, "<xsl:variable name=\"%s__index\" select=\"count(set:intersection(following::*, .|.|.|%s))\" />", context->name, expr);	
	
	// <title><xsl:value-of select="key('page-key', $page_index)/h1" /></title>
	
	__dex_simple_single_object(json, buf, context);
	sprintbuf(buf, "</dexter:group></xsl:for-each></dexter:groups>\n");
}

static void __dex_simple_array_string(struct json_object * json, struct printbuf * buf, contextPtr context){
	char* expr = myparse(astrdup(json_object_get_string(json)));
	sprintbuf(buf, "<xsl:variable name=\"%s\" select=\"%s\" />\n", context->name, expr);
	sprintbuf(buf, "<xsl:variable name=\"%s\" select=\"$%s\" />\n", __tag(context->name), context->name);
	sprintbuf(buf, "<dexter:groups><xsl:for-each select=\"$%s\"><dexter:group>\n", context->name);	
	sprintbuf(buf, "<xsl:value-of select=\".\" />\n", context->name);
	sprintbuf(buf, "</dexter:group></xsl:for-each></dexter:groups>\n");
}

static char* full_expr(contextPtr context, char* expr){
	return expr_join(context->expr, expr);
}

static char* expr_join(char* base, char* expr) {
	return astrcat3(base, " | ", expr);
}



